import os
import re
from pathlib import Path

# Configuration
PROJECT_ROOT = Path(__file__).parent.parent.resolve()
OUTPUT_FILE = PROJECT_ROOT / "scripts" / "berny-super-knowledge.js"

# Folders to scan
SCAN_CONFIG = {
    "data/quiz": [".txt"],
    "pages": [".html"],
    "scripts/i18n": [".json"],
    ".": [".html"] # Root HTML files
}

IGNORE_DIRS = {
    "node_modules", ".git", ".venv", "__pycache__", 
    "backup_", "build-tools", "assets", "styles"
}

def clean_html(html_content):
    """Removes HTML tags, scripts, and styles, leaving only readable text."""
    # Remove scripts and styles
    cleaned = re.sub(r'<(script|style)[^>]*>.*?</\1>', '', html_content, flags=re.DOTALL | re.IGNORECASE)
    # Remove comments
    cleaned = re.sub(r'<!--.*?-->', '', cleaned, flags=re.DOTALL)
    # Remove tags
    cleaned = re.sub(r'<[^>]+>', ' ', cleaned)
    # Collapse whitespace
    cleaned = re.sub(r'\s+', ' ', cleaned).strip()
    return cleaned

def build_context():
    full_text = []
    print(f"üîç Scanning project for knowledge in: {PROJECT_ROOT}")

    # Walk through the project
    for root, dirs, files in os.walk(PROJECT_ROOT):
        # Filter ignored directories
        dirs[:] = [d for d in dirs if d not in IGNORE_DIRS and not any(d.startswith(p) for p in ["backup_", "."])]
        
        rel_root = os.path.relpath(root, PROJECT_ROOT)
        
        for file in files:
            file_path = Path(root) / file
            ext = file_path.suffix.lower()
            
            # Check if this file should be scanned based on its location and extension
            should_scan = False
            for folder, extensions in SCAN_CONFIG.items():
                if (rel_root == folder or rel_root.startswith(folder + os.sep) or folder == ".") and ext in extensions:
                    should_scan = True
                    break
            
            if not should_scan:
                continue

            try:
                with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                    content = f.read().strip()
                    if not content:
                        continue

                    # Process content based on type
                    if ext == ".html":
                        processed_content = clean_html(content)
                    elif ext == ".json":
                        # Just keep it as string, maybe pretty print if it's small
                        processed_content = content
                    else:
                        processed_content = content

                    if processed_content:
                        header = f"\n=== FONTE: {os.path.relpath(file_path, PROJECT_ROOT)} ===\n"
                        full_text.append(header + processed_content)
                        print(f"‚úÖ Added: {os.path.relpath(file_path, PROJECT_ROOT)}")

            except Exception as e:
                print(f"‚ùå Error reading {file}: {e}")

    return "\n".join(full_text)

def save_output(context_text):
    # Escape backticks for JS template literal
    escaped_text = context_text.replace("`", "\\`").replace("${", "\\${")
    
    js_content = f"""/**
 * BERNY SUPER KNOWLEDGE BASE
 * Auto-generated by build-tools/build_knowledge.py
 * Contains the full text context of the application for AI consumption.
 */

const FULL_APP_CONTEXT = `{escaped_text}`;

if (typeof window !== 'undefined') {{
    window.FULL_APP_CONTEXT = FULL_APP_CONTEXT;
}}
"""
    
    # Ensure directory exists
    OUTPUT_FILE.parent.mkdir(parents=True, exist_ok=True)
    
    with open(OUTPUT_FILE, "w", encoding="utf-8") as f:
        f.write(js_content)
    
    print(f"\nüöÄ Success! Knowledge base saved to: {OUTPUT_FILE}")

if __name__ == "__main__":
    context = build_context()
    if context:
        save_output(context)
    else:
        print("‚ö†Ô∏è No content found to build knowledge base.")
